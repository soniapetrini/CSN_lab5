---
title: "CSN_lab5"
output: html_document
---

```{r}
library(igraph)
library(igraphdata)
library(ggplot2)

data("foodwebs")
foodweb_net <- as.undirected(foodwebs[[9]], mode = "collapse")
print("foodweb_net")
gsize(foodweb_net)
gorder(foodweb_net)

data("macaque")
macaque_net <- as.undirected(macaque, mode = "collapse")
print("macaque_net")
gsize(macaque_net)
gorder(macaque_net)

data("enron")
enron_net <- enron
print("enron_net")
gsize(enron_net)
gorder(enron_net)

karate_net <- graph.famous("Zachary")
```


Algorithms to try:

• *edge.betweenness.community* [Newman and Girvan, 2004]
• *fastgreedy.community* [Clauset et al., 2004]: modularity greedy opti-
mization method.
• *label.propagation.community* [Raghavan et al., 2007]: This is a fast, nearly linear time algorithm for detecting community structure in net- works. It works by labeling the vertices with unique labels and then updating the labels by majority voting in the neighborhood of the vertex.
• *leading.eigenvector.community* [Newman, 2006]
• *multilevel.community* [Blondel et al., 2008]: This is a multi-level modularity optimization algorithm (the Louvain method).
• *optimal.community* [Brandes et al., 2008]: Works by maximizing the mod- ularity measure over all possible partitions.
• *spinglass.community* [Reichardt and Bornholdt, 2006]: tries to find com- munities in graphs via a spin-glass model and simulated annealing.
• *walktrap.community* [Pons and Latapy, 2005]: tries to find densely con- nected subgraphs (communities) in a graph via random walks. The idea is that short random walks tend to stay in the same community.
• *infomap.community* [Rosvall and Bergstrom, 2008]: Find community struc- ture that minimizes the expected description length of a random walker tra jectory.


```{r}
merge_communities <- function(graphs, difficulty = length(graphs)+15 ) {
  
  # difficulty is an integer equal to the number of edges to add between communities
  
  labels <- seq(1,1000,50)
  EL_union <- c()
  nodes <- list()
  for (i in 1:length(graphs)) {
    g <- make_graph(graphs[i])
    # rename vertices
    possible_vertex_names <- seq(labels[i],labels[i+1])
    g_labels <- as.character(sample(possible_vertex_names,vcount(g)))
    vertex_attr(g) <- list(name = g_labels)
    EL  = get.edgelist(g)
    EL_union <- rbind(EL_union,EL)
    nodes[[i]] <- V(g)
  }
  GU = graph_from_edgelist(EL_union, directed=FALSE)
  
  # add some between-communities edges
  x <- combn(V(GU),2)
  random_edges <- x[,sample(seq(dim(x)[2]),difficulty,replace=F)]
  
  fixed_edges <- c(nodes[[1]][1],nodes[[2]][1],nodes[[2]][1],nodes[[3]][1])
  
  GU <- GU + edges(random_edges) + edges()
  return(GU)
}

graphs <- c("Coxeter","Folkman","Herschel","Icosahedral","Cubical")
merge_communities(graphs[1:3])


names(nodes[[1]])
```


```{r}
library(tidyr)
library(viridis)
df_long <- df %>% pivot_longer(-algortihm, names_to = "Var", values_to = "val")

df[,-ncol(df)] %>% pivot_longer(-algortihm, names_to = "Var", values_to = "val") %>%
  ggplot(aes(x = Var, y = val, size=val, color=algortihm))+
  geom_point() +
  scale_size(range = c(1, 10), name="Population (M)") +
  scale_fill_viridis(discrete=TRUE, guide=FALSE, option="A") +
  theme(legend.position="bottom") +
  ylab("Value") +
  xlab("Measure") +
  theme(legend.position = "none")

```


```{r}
library(dplyr)

nets <- list("macaque_net"=macaque_net,"karate_net"=karate_net,
             "my_net"=my_net,"foodwebs_net"=foodweb_net)


df <- read.csv("foodwebs_net_df.csv")
  
setEPS()
postscript("foodweb_net_measures.eps")
df[,-c(1,ncol(df))] %>% pivot_longer(-algorithm, names_to = "Var", values_to = "val") %>%
  ggplot(aes(x=Var,y=val,fill=algorithm)) +
    geom_bar(stat="identity",position="dodge") +
    scale_fill_discrete(name="algortihm") +
    xlab("Measure")+ylab("Value")
dev.off()

```













