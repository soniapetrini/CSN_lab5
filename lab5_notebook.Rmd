---
title: "CSN_lab5"
output: html_document
---

```{r}
library(igraph)
library(igraphdata)
library(ggplot2)
library(reshape)
library(viridis)
library(dplyr)

data("foodwebs")
foodweb_net <- as.undirected(foodwebs[[9]], mode = "collapse")
print("foodweb_net")
gsize(foodweb_net)
gorder(foodweb_net)

data("macaque")
macaque_net <- as.undirected(macaque, mode = "collapse")
print("macaque_net")
gsize(macaque_net)
gorder(macaque_net)

data("enron")
enron_net <- enron
print("enron_net")
gsize(enron_net)
gorder(enron_net)

karate_net <- graph.famous("Zachary")
```


Algorithms to try:

• *edge.betweenness.community* [Newman and Girvan, 2004]
• *fastgreedy.community* [Clauset et al., 2004]: modularity greedy opti-
mization method.
• *label.propagation.community* [Raghavan et al., 2007]: This is a fast, nearly linear time algorithm for detecting community structure in net- works. It works by labeling the vertices with unique labels and then updating the labels by majority voting in the neighborhood of the vertex.
• *leading.eigenvector.community* [Newman, 2006]
• *multilevel.community* [Blondel et al., 2008]: This is a multi-level modularity optimization algorithm (the Louvain method).
• *optimal.community* [Brandes et al., 2008]: Works by maximizing the mod- ularity measure over all possible partitions.
• *spinglass.community* [Reichardt and Bornholdt, 2006]: tries to find com- munities in graphs via a spin-glass model and simulated annealing.
• *walktrap.community* [Pons and Latapy, 2005]: tries to find densely con- nected subgraphs (communities) in a graph via random walks. The idea is that short random walks tend to stay in the same community.
• *infomap.community* [Rosvall and Bergstrom, 2008]: Find community struc- ture that minimizes the expected description length of a random walker tra jectory.



# Plot of results for a Network

```{r}
nets <- list("macaque_net"=macaque_net,"karate_net"=karate_net,
             "my_net"=my_net,"foodwebs_net"=foodweb_net)

df <- read.csv("foodwebs_net_df.csv")
  
setEPS()
postscript("foodweb_net_measures.eps")
df[,-c(1,ncol(df))] %>% pivot_longer(-algorithm, names_to = "Var", values_to = "val") %>%
  ggplot(aes(x=Var,y=val,fill=algorithm)) +
    geom_bar(stat="identity",position="dodge") +
    scale_fill_discrete(name="algortihm") +
    xlab("Measure")+ylab("Value")
dev.off()

```


# Plot for different difficulty values

```{r}
graphs <- c("Coxeter","Folkman","Herschel","Cubical")

est_clusters <- list()
i <- 1
difficulties <- seq(0,100)
for (d in difficulties) {
  graph_d <- merge_communities(graphs, difficulty = d)
  df <- find_communities(graph_d)
  est_clusters[[i]] <- df$clusters
  i <- i + 1
}

results <- list("edge.betweenness"=NULL,"fastgreedy"=NULL,"label.propagation"=NULL,"leading.eigenvector"=NULL,
            "multilevel"=NULL,"spinglass"=NULL,"walktrap"=NULL,"infomap"=NULL)
for (i in 1:length(algorithms)) {
  results[[i]] <- as.numeric(lapply(est_clusters, `[[`, i))
}


# estimated clusters
data.frame(results) %>%  select(1:4) %>% mutate(difficulty=difficulties) %>% 
  melt(id.vars="difficulty") %>%
  ggplot(aes( x=difficulty, y=value, colour=variable, group=variable )) + 
  geom_line() +
  geom_hline(yintercept=4, linetype="dashed", 
                color = "red", size=1) +
  ylab("estimated number of clusters")

# error 

data.frame(results) %>%  select(5:8) %>% mutate(difficulty=difficulties) %>%
  melt(id.vars="difficulty") %>%
  ggplot(aes( x=difficulty, y=value, colour=variable, group=variable )) + 
  geom_line() +
  geom_hline(yintercept=4, linetype="dashed", 
                color = "red", size=1) +
  ylab("estimated number of clusters")

```











