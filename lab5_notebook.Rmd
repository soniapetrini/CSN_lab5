---
title: "CSN_lab5"
output: html_document
---

```{r}
library(igraph)
library(igraphdata)

data("foodwebs")
foodweb_net <- as.undirected(foodwebs[[9]], mode = "collapse")
print("foodweb_net")
gsize(foodweb_net)
gorder(foodweb_net)

data("macaque")
macaque_net <- as.undirected(macaque, mode = "collapse")
print("macaque_net")
gsize(macaque_net)
gorder(macaque_net)

data("enron")
enron_net <- enron
print("enron_net")
gsize(enron_net)
gorder(enron_net)
```


Algorithms to try:

• *edge.betweenness.community* [Newman and Girvan, 2004]
• *fastgreedy.community* [Clauset et al., 2004]: modularity greedy opti-
mization method.
• *label.propagation.community* [Raghavan et al., 2007]: This is a fast, nearly linear time algorithm for detecting community structure in net- works. It works by labeling the vertices with unique labels and then updating the labels by majority voting in the neighborhood of the vertex.
• *leading.eigenvector.community* [Newman, 2006]
• *multilevel.community* [Blondel et al., 2008]: This is a multi-level modularity optimization algorithm (the Louvain method).
• *optimal.community* [Brandes et al., 2008]: Works by maximizing the mod- ularity measure over all possible partitions.
• *spinglass.community* [Reichardt and Bornholdt, 2006]: tries to find com- munities in graphs via a spin-glass model and simulated annealing.
• *walktrap.community* [Pons and Latapy, 2005]: tries to find densely con- nected subgraphs (communities) in a graph via random walks. The idea is that short random walks tend to stay in the same community.
• *infomap.community* [Rosvall and Bergstrom, 2008]: Find community struc- ture that minimizes the expected description length of a random walker tra jectory.


```{r}

get_expansion <- function(graph,communities) {
  memberships <- membership(communities)
  list <- c()
  i <- 1
  for (edge_index in 1:length(E(graph))) {
        edge_nodes <- V(graph)[ inc(edge_index) ]$name
        if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
          list[i] <- memberships[edge_nodes[1]]
          list[i+1] <- memberships[edge_nodes[2]]
          i <- i + 2
        }
  }
  expansions <- table(list)/table(memberships)
  expansion <- mean(expansions)
  return(expansion)
}

communities <- edge.betweenness.community(macaque)
get_expansion(macaque,communities)

```


# measures

```{r}
#TPR
lennart <- read.csv("algs_results_foodwebs.csv")
```





```{r}

```




