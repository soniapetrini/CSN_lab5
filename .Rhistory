if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
}
i <- i + 1
}
list <- c()
i <- 1
for (edge_index in length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
i <- i + 1
}
}
list <- c()
i <- 1
for (edge_index in length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
i <- i + 1
}
else {print("else")}
}
length(E(foodweb_net_s))
i <- 1
for (m in unique(memberships)) {
cluster_edge_list <- c()
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
print(edge_nodes[1])
print(edge_nodes[2])
if (edge_nodes[1] %in% memberships[memberships==m] &
edge_nodes[2] %!in% memberships[memberships==m] ) {
cluster_edge_list[i] <- 1
print("between edge")
}
else if (edge_nodes[1] %!in% memberships[memberships==m] &
edge_nodes[2] %in% memberships[memberships==m]) {
cluster_edge_list[i] <- 1
print("between edge")
}
else {cluster_edge_list[i] <- 0}
i <- i+1
}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
i <- i + 1
}
else {print("else")}
}
length(E(foodweb_net_s))
list
list[1] <- memberships[edge_nodes[1]]
list[1+1] <- memberships[edge_nodes[2]]
list[1] <- memberships[edge_nodes[1]]
list[1+1] <- memberships[edge_nodes[2]]
memberships[edge_nodes[1]] != memberships[edge_nodes[2]]
list <- c()
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[edge_index] <- memberships[edge_nodes[1]]
list[edge_index+1] <- memberships[edge_nodes[2]]
}
else {print("else")}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
i <- i + 1
}
else {print("else")}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
print(list)
i <- i + 1
}
else {print("else")}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
append(list,memberships[edge_nodes[1]])
append(list,memberships[edge_nodes[2]])
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
print(list)
i <- i + 1
}
else {print("else")}
}
append(list,memberships[edge_nodes[2]])
list <- c(2)
append(list,memberships[edge_nodes[2]])
list <- c(2)
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
append(list,memberships[edge_nodes[1]])
append(list,memberships[edge_nodes[2]])
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
print(list)
}
else {print("else")}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
print(list)
i <- i + 1
}
else {print("else")}
}
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
print(memberships[edge_nodes[1]])
print(memberships[edge_nodes[2]])
print(list)
i <- i + 2
}
else {print("else")}
}
table(list)
members <- memberships[memberships==4]
nodes <- names(members)
subgraph <- induced_subgraph(foodweb_net_s,nodes,impl = "auto")
sub_nodes <- vcount(subgraph)
sub_nodes <- ecount(subgraph)
table(list)
length(E(foodweb_net_s))
sub_nodes <- ncount(subgraph)
sub_nodes <- ncount(subgraph)
sub_nodes <- vcount(subgraph)
list <- c()
i <- 1
for (edge_index in 1:length(E(foodweb_net_s))) {
edge_nodes <- V(foodweb_net_s)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
i <- i + 2
}
}
table(memberships)
table(list)/table(memberships)
table(list)
table(memberships)
158/19
table(list)/table(memberships)
expansions <- table(list)/table(memberships)
expansions
get_expansion <- function(graph,communities) {
memberships <- membership(communities)
list <- c()
i <- 1
for (edge_index in 1:length(E(graph))) {
edge_nodes <- V(graph)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
i <- i + 2
}
}
expansions <- table(list)/table(memberships)
expansion <- mean(expansions)
return(expansion)
}
get_expansion(foodweb_net_s,communities)
communities <- edge.betweenness.community(macaque)
get_expansion(macaque,communities)
find_communities <- function(graph) {
graph <- as.undirected(graph, mode='collapse')
graph <- simplify(graph)
# edge.betweeness
communities <- edge.betweenness.community(graph)
mod_1 <- modularity(communities)
tpr_1 <- get_TPR(graph, communities)
exp_1 <- get_expansion(graph,communities)
# fastgreedy.community
communities <- fastgreedy.community(graph)
mod_2 <- modularity(communities)
tpr_2 <- get_TPR(graph, communities)
exp_2 <- get_expansion(graph,communities)
# label propagation
communities <-  cluster_label_prop(graph)
mod_3 <- modularity(communities)
tpr_3 <- get_TPR(graph, communities)
exp_3 <- get_expansion(graph,communities)
# leading eigenvector
Isolated = which(degree(foodweb_net)==0)
if (length(Isolated) != 0) {
graph = delete.vertices(graph, Isolated)
}
arpack_defaults$maxiter = 1000000000
communities <- leading.eigenvector.community(graph, options = arpack_defaults)
mod_4 <- modularity(communities)
tpr_4 <- get_TPR(graph, communities)
exp_4 <- get_expansion(graph,communities)
# louvain method (multilevel)
communities <- cluster_louvain(graph)
mod_5 <- modularity(communities)
tpr_5 <- get_TPR(graph, communities)
exp_5 <- get_expansion(graph,communities)
# optimal clustering
#â—Š# not working on mac, package required
# spinglass
communities <- cluster_spinglass(graph)
mod_7 <- modularity(communities)
tpr_7 <- get_TPR(graph, communities)
exp_7 <- get_expansion(graph,communities)
# walktrap
communities <- walktrap.community(graph)
mod_8 <- modularity(communities)
tpr_8 <- get_TPR(graph, communities)
exp_8 <- get_expansion(graph,communities)
# infomap
communities <- cluster_infomap(graph)
mod_9 <- modularity(communities)
tpr_9 <- get_TPR(graph, communities)
exp_9 <- get_expansion(graph,communities)
modularities <- c(mod_1,mod_2,mod_3,mod_4,mod_5,mod_7,mod_8,mod_9)
TPRs <- c(tpr_1,tpr_2,tpr_3,tpr_4,tpr_5,tpr_7,tpr_8,tpr_9)
expansions <- c(exp_1,exp_2,exp_3,exp_4,exp_5,exp_7,exp_8,exp_9)
return(data.frame("algorithm"=algorithms,"modularity" = modularities,
"TPR" = TPRs,"expansion" = expansions))
}
measures_airports <- find_communities(macaque_net)
library(igraph)
library(igraphdata)
rm(list=ls())
# get nets
data("foodwebs")
foodweb_net <- as.undirected(foodwebs[[9]], mode = "collapse")
data("macaque")
macaque_net <- as.undirected(macaque, mode = "collapse")
# define globals
nets <- c(foodweb_net,macaque_net)
algorithms <- c("edge.betweenness.community",
"fastgreedy.community",
"label.propagation.community",
"leading.eigenvector.community",
"multilevel.community",
"spinglass.community",
"walktrap.community",
"infomap.community")
# MEASURES
## Triangle Participation Ratio
get_TPR <- function(graph, communities) {
memberships <- membership(communities)
tpr_clusters <- c()
i <- 1
w <- c()
for (m in unique(memberships)) {
members <- memberships[memberships==m]
nodes <- names(members)
subgraph <- induced_subgraph(graph,nodes,impl = "auto")
sub_nodes <- vcount(subgraph)
w[i] <- sub_nodes
nodes_in_triads <- unique(triangles(subgraph))
tpr_clusters[i] <- length(nodes_in_triads)/sub_nodes
i <- i + 1
}
tpr <- weighted.mean(tpr_clusters, w)
return(tpr)
}
## Expansion
get_expansion <- function(graph,communities) {
memberships <- membership(communities)
list <- c()
i <- 1
for (edge_index in 1:length(E(graph))) {
edge_nodes <- V(graph)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
i <- i + 2
}
}
expansions <- table(list)/table(memberships)
expansion <- mean(expansions)
return(expansion)
}
help(mean)
# IMPLEMENTATION
find_communities <- function(graph) {
graph <- as.undirected(graph, mode='collapse')
graph <- simplify(graph)
# edge.betweeness
communities <- edge.betweenness.community(graph)
mod_1 <- modularity(communities)
tpr_1 <- get_TPR(graph, communities)
exp_1 <- get_expansion(graph,communities)
# fastgreedy.community
communities <- fastgreedy.community(graph)
mod_2 <- modularity(communities)
tpr_2 <- get_TPR(graph, communities)
exp_2 <- get_expansion(graph,communities)
# label propagation
communities <-  cluster_label_prop(graph)
mod_3 <- modularity(communities)
tpr_3 <- get_TPR(graph, communities)
exp_3 <- get_expansion(graph,communities)
# leading eigenvector
Isolated = which(degree(foodweb_net)==0)
if (length(Isolated) != 0) {
graph = delete.vertices(graph, Isolated)
}
arpack_defaults$maxiter = 1000000000
communities <- leading.eigenvector.community(graph, options = arpack_defaults)
mod_4 <- modularity(communities)
tpr_4 <- get_TPR(graph, communities)
exp_4 <- get_expansion(graph,communities)
# louvain method (multilevel)
communities <- cluster_louvain(graph)
mod_5 <- modularity(communities)
tpr_5 <- get_TPR(graph, communities)
exp_5 <- get_expansion(graph,communities)
# optimal clustering
#â—Š# not working on mac, package required
# spinglass
communities <- cluster_spinglass(graph)
mod_7 <- modularity(communities)
tpr_7 <- get_TPR(graph, communities)
exp_7 <- get_expansion(graph,communities)
# walktrap
communities <- walktrap.community(graph)
mod_8 <- modularity(communities)
tpr_8 <- get_TPR(graph, communities)
exp_8 <- get_expansion(graph,communities)
# infomap
communities <- cluster_infomap(graph)
mod_9 <- modularity(communities)
tpr_9 <- get_TPR(graph, communities)
exp_9 <- get_expansion(graph,communities)
modularities <- c(mod_1,mod_2,mod_3,mod_4,mod_5,mod_7,mod_8,mod_9)
TPRs <- c(tpr_1,tpr_2,tpr_3,tpr_4,tpr_5,tpr_7,tpr_8,tpr_9)
expansions <- c(exp_1,exp_2,exp_3,exp_4,exp_5,exp_7,exp_8,exp_9)
return(data.frame("algorithm"=algorithms,"modularity" = modularities,
"TPR" = TPRs,"expansion" = expansions))
}
# STORAGE
measures_airports <- find_communities(macaque_net)
#for (net in nets) {
#  measures <- find_communities(foodweb_net)
#  measures_df <- data.frame("algorithm"=algorithms,"modularities" = measures$modularities,"TPRs" = measures$TPRs)
#}
write.csv(measures_airports, "measures_foodwebs.csv")
measures_airports
library(igraph)
library(igraphdata)
rm(list=ls())
# get nets
data("foodwebs")
foodweb_net <- as.undirected(foodwebs[[9]], mode = "collapse")
data("macaque")
macaque_net <- as.undirected(macaque, mode = "collapse")
# define globals
nets <- c(foodweb_net,macaque_net)
algorithms <- c("edge.betweenness.community",
"fastgreedy.community",
"label.propagation.community",
"leading.eigenvector.community",
"multilevel.community",
"spinglass.community",
"walktrap.community",
"infomap.community")
# MEASURES
## Triangle Participation Ratio
get_TPR <- function(graph, communities) {
memberships <- membership(communities)
tpr_clusters <- c()
i <- 1
w <- c()
for (m in unique(memberships)) {
members <- memberships[memberships==m]
nodes <- names(members)
subgraph <- induced_subgraph(graph,nodes,impl = "auto")
sub_nodes <- vcount(subgraph)
w[i] <- sub_nodes
nodes_in_triads <- unique(triangles(subgraph))
tpr_clusters[i] <- length(nodes_in_triads)/sub_nodes
i <- i + 1
}
tpr <- weighted.mean(tpr_clusters, w)
return(tpr)
}
## Expansion
get_expansion <- function(graph,communities) {
memberships <- membership(communities)
list <- c()
i <- 1
for (edge_index in 1:length(E(graph))) {
edge_nodes <- V(graph)[ inc(edge_index) ]$name
if (memberships[edge_nodes[1]] != memberships[edge_nodes[2]]) {
list[i] <- memberships[edge_nodes[1]]
list[i+1] <- memberships[edge_nodes[2]]
i <- i + 2
}
}
expansions <- table(list)/table(memberships)
expansion <- mean(expansions)
return(expansion)
}
help(mean)
# IMPLEMENTATION
find_communities <- function(graph) {
graph <- as.undirected(graph, mode='collapse')
graph <- simplify(graph)
# edge.betweeness
communities <- edge.betweenness.community(graph)
mod_1 <- modularity(communities)
tpr_1 <- get_TPR(graph, communities)
exp_1 <- get_expansion(graph,communities)
# fastgreedy.community
communities <- fastgreedy.community(graph)
mod_2 <- modularity(communities)
tpr_2 <- get_TPR(graph, communities)
exp_2 <- get_expansion(graph,communities)
# label propagation
communities <-  cluster_label_prop(graph)
mod_3 <- modularity(communities)
tpr_3 <- get_TPR(graph, communities)
exp_3 <- get_expansion(graph,communities)
# leading eigenvector
Isolated = which(degree(foodweb_net)==0)
if (length(Isolated) != 0) {
graph = delete.vertices(graph, Isolated)
}
arpack_defaults$maxiter = 1000000000
communities <- leading.eigenvector.community(graph, options = arpack_defaults)
mod_4 <- modularity(communities)
tpr_4 <- get_TPR(graph, communities)
exp_4 <- get_expansion(graph,communities)
# louvain method (multilevel)
communities <- cluster_louvain(graph)
mod_5 <- modularity(communities)
tpr_5 <- get_TPR(graph, communities)
exp_5 <- get_expansion(graph,communities)
# optimal clustering
#â—Š# not working on mac, package required
# spinglass
communities <- cluster_spinglass(graph)
mod_7 <- modularity(communities)
tpr_7 <- get_TPR(graph, communities)
exp_7 <- get_expansion(graph,communities)
# walktrap
communities <- walktrap.community(graph)
mod_8 <- modularity(communities)
tpr_8 <- get_TPR(graph, communities)
exp_8 <- get_expansion(graph,communities)
# infomap
communities <- cluster_infomap(graph)
mod_9 <- modularity(communities)
tpr_9 <- get_TPR(graph, communities)
exp_9 <- get_expansion(graph,communities)
modularities <- c(mod_1,mod_2,mod_3,mod_4,mod_5,mod_7,mod_8,mod_9)
TPRs <- c(tpr_1,tpr_2,tpr_3,tpr_4,tpr_5,tpr_7,tpr_8,tpr_9)
expansions <- c(exp_1,exp_2,exp_3,exp_4,exp_5,exp_7,exp_8,exp_9)
return(data.frame("algorithm"=algorithms,"modularity" = modularities,
"TPR" = TPRs,"expansion" = expansions))
}
# STORAGE
measures_food <- find_communities(foodweb_net)
#for (net in nets) {
#  measures <- find_communities(foodweb_net)
#  measures_df <- data.frame("algorithm"=algorithms,"modularities" = measures$modularities,"TPRs" = measures$TPRs)
#}
write.csv(measures_food, "measures_foodwebs.csv")
measures_food
